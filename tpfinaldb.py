# -*- coding: utf-8 -*-
"""TPfinalDB.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1RJrd0QEsT7pJejlDjm8nhlNjom-hxh7y
"""

#Desarrollo de Clases e Interfaces
#Creamos clases e interfaces que encapsulen los atributos y comportamientos de los personajes en el juego.

#Clase Personaje
#Implementamos una clase Personaje que representa a los personajes del juego, con atributos como nombre, nivel de poder, habilidades y raza.
class Personaje:
    def __init__(self, nombre, raza, nivel_poder, habilidades=None):
        self.nombre = nombre
        self.raza = raza  # Ejemplo: Saiyajin, Namekuseijin, Terrícola
        self.nivel_poder = nivel_poder
        self.habilidades = habilidades if habilidades else []

    def mostrar_informacion(self):
        return f"Nombre: {self.nombre}, Raza: {self.raza}, Nivel de Poder: {self.nivel_poder}, Habilidades: {', '.join(self.habilidades)}"

    def subir_nivel(self, incremento):
        self.nivel_poder += incremento

    def agregar_habilidad(self, habilidad):
        self.habilidades.append(habilidad)

#Interfaz de Combate
#Creamos una interfaz Combate para simular enfrentamientos entre personajes.
class Combate:
    def __init__(self, personaje1, personaje2):
        self.personaje1 = personaje1
        self.personaje2 = personaje2

    def iniciar_combate(self):
        print(f"¡Comienza el combate entre {self.personaje1.nombre} y {self.personaje2.nombre}!")
        if self.personaje1.nivel_poder > self.personaje2.nivel_poder:
            return f"Ganador: {self.personaje1.nombre}"
        elif self.personaje1.nivel_poder < self.personaje2.nivel_poder:
            return f"Ganador: {self.personaje2.nombre}"
        return "¡Empate!"

#Algoritmo Recursivo
#Utilizamos una estructura recursiva para calcular la evolución de poder de un personaje, considerando transformaciones como el Super Saiyajin o Kaioken.
def evolucion_poder(nivel_inicial, combates_restantes, multiplicador):
    if combates_restantes == 0:
        return nivel_inicial
    return evolucion_poder(nivel_inicial * multiplicador, combates_restantes - 1, multiplicador)

#Árbol Binario
#Implementamos un árbol binario para organizar a los personajes en función de su nivel de poder, permitiendo una búsqueda rápida de los personajes más fuertes para los enfrentamientos.
class NodoArbol:
    def __init__(self, personaje):
        self.personaje = personaje
        self.izquierda = None
        self.derecha = None

class ArbolBinario:
    def __init__(self):
        self.raiz = None

    def insertar(self, personaje):
        if not self.raiz:
            self.raiz = NodoArbol(personaje)
        else:
            self._insertar(self.raiz, personaje)

    def _insertar(self, nodo_actual, personaje):
        if personaje.nivel_poder < nodo_actual.personaje.nivel_poder:
            if nodo_actual.izquierda is None:
                nodo_actual.izquierda = NodoArbol(personaje)
            else:
                self._insertar(nodo_actual.izquierda, personaje)
        else:
            if nodo_actual.derecha is None:
                nodo_actual.derecha = NodoArbol(personaje)
            else:
                self._insertar(nodo_actual.derecha, personaje)

    def inorden(self, nodo=None):
        if nodo is None:
            nodo = self.raiz
        if nodo.izquierda:
            self.inorden(nodo.izquierda)
        print(nodo.personaje.mostrar_informacion())
        if nodo.derecha:
            self.inorden(nodo.derecha)

#Árbol de Habilidades
#Modelamos el árbol de habilidades de un personaje como un árbol general, donde cada nodo representa una habilidad y sus ramas muestran las transformaciones derivadas de ella.
class NodoHabilidad:
    def __init__(self, habilidad):
        self.habilidad = habilidad
        self.sub_habilidades = []

    def agregar_sub_habilidad(self, sub_habilidad):
        self.sub_habilidades.append(NodoHabilidad(sub_habilidad))

#Cola de Prioridades con Heap Binario
#implementamos una cola de prioridades usando un heap binario para gestionar los combates en un torneo. Los personajes con mayor nivel de poder tendrán prioridad.
import heapq
class Torneo:
    def __init__(self):
        self.cola_prioridad = []

    def agregar_personaje(self, personaje):
        # Usamos el negativo del nivel de poder para que el personaje más fuerte tenga mayor prioridad
        heapq.heappush(self.cola_prioridad, (-personaje.nivel_poder, personaje))

    def siguiente_combate(self):
        if self.cola_prioridad:
            return heapq.heappop(self.cola_prioridad)[1]
        return None

#Análisis de Algoritmos
#Analizamos la eficiencia de los algoritmos implementados en términos de tiempo y espacio:
#Inserción en Árbol Binario: O(log n) en el caso promedio, O(n) en el peor caso.
#Recorridos DFS/BFS: O(V + E), donde V son los vértices (planetas/personajes) y E son las aristas (conexiones entre ellos).
#Gestión de Cola de Prioridad: O(log n) por operación.

#Grafos
#Usamos un grafo para modelar el universo de Dragon Ball, donde los nodos representan planetas y las aristas son las rutas espaciales entre ellos.
import networkx as nx
grafo = nx.Graph()
grafo.add_edge("Tierra", "Namek", weight=5)
grafo.add_edge("Tierra", "Vegeta", weight=10)
grafo.add_edge("Namek", "Vegeta", weight=8)

#Recorridos DFS y BFS
#Usamos los algoritmos DFS (Depth-First Search) y BFS (Breadth-First Search) para explorar los planetas y encontrar rutas entre ellos.
dfs = list(nx.dfs_edges(grafo, source="Tierra"))
bfs = list(nx.bfs_edges(grafo, source="Tierra"))

#Ordenamiento Topológico
#El ordenamiento topológico se utiliza para planificar el entrenamiento de un personaje, donde ciertas habilidades deben dominarse antes que otras.
dag = nx.DiGraph()
dag.add_edges_from([("Ki básico", "Kamehameha"), ("Kamehameha", "Kamehameha x10")])
orden_topologico = list(nx.topological_sort(dag))

#Problemas NP y Camino Mínimo
#Aplicamos el problema del camino mínimo utilizando el algoritmo de Dijkstra para encontrar la ruta más rápida entre planetas, con el objetivo de recolectar las Esferas del Dragón de la manera más eficiente posible.

#Problema del Camino Mínimo: Dijkstra
#El problema del camino mínimo consiste en encontrar la ruta más corta (en términos de peso o distancia) entre dos nodos en un grafo. En el contexto de nuestro juego, el grafo está formado por planetas y rutas espaciales, donde cada arista tiene un peso que puede representar tiempo, distancia o recursos necesarios para viajar entre los planetas.
#Utilizando el algoritmo de Dijkstra, podemos calcular el camino más corto entre dos planetas, lo que es esencial para simular la recolección eficiente de las Esferas del Dragón. Cada planeta es un nodo, y las rutas entre ellos son aristas ponderadas.

#Implementación de Dijkstra en Python
#Para aplicar el algoritmo de Dijkstra, utilizamos la librería NetworkX en Python, que proporciona herramientas eficientes para trabajar con grafos.
import networkx as nx

# Crear un grafo ponderado que representa el universo de Dragon Ball
grafo = nx.Graph()

# Agregar planetas y rutas (aristas ponderadas)
grafo.add_edge("Tierra", "Namek", weight=5)  # Peso=5 unidades de distancia
grafo.add_edge("Tierra", "Vegeta", weight=10)  # Peso=10 unidades de distancia
grafo.add_edge("Namek", "Vegeta", weight=8)  # Peso=8 unidades de distancia
grafo.add_edge("Vegeta", "Makai", weight=7)  # Peso=7 unidades de distancia
grafo.add_edge("Makai", "Tierra", weight=3)  # Peso=3 unidades de distancia

# Función que utiliza el algoritmo de Dijkstra para encontrar el camino más corto
def encontrar_camino_minimo(grafo, origen, destino):
    # Ejecutamos Dijkstra para encontrar el camino más corto
    ruta_minima = nx.dijkstra_path(grafo, source=origen, target=destino, weight='weight')
    distancia_minima = nx.dijkstra_path_length(grafo, source=origen, target=destino, weight='weight')
    return ruta_minima, distancia_minima

# Ejemplo: encontrar el camino más corto entre Tierra y Makai
ruta, distancia = encontrar_camino_minimo(grafo, "Tierra", "Makai")
print(f"Ruta más corta entre Tierra y Makai: {ruta}")
print(f"Distancia mínima: {distancia} unidades")